<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>Accessing the Codecs Directly with the RIB Interface</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="">
<meta name="ms-hkwd" content="Accessing the Codecs Directly with the RIB Interface">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Miles Sound System SDK 6.6h</a></i>
</td>
</tr>
</table>
<h1>Accessing the Codecs Directly with the RIB Interface</h1>
<h4>Discussion</h4>
<p> Most MSS applications don't need to access the library's ASI (Audio Stream Interface) layer directly - the details of communicating with individual ASI providers are encapsulated by high-level library functions such as the streaming and quick-integration APIs. However, real-time voice chat is an exception. To achieve good latency performance and full control over the compression/decompression process, it's necessary for the application to gain low-level access to the Voxware codecs by means of the ASI interface. </p><p>The ASI standard represents a very simple, generalized interface for MSS-compatible audio compression and decompression codecs. ASI uses the RAD Interface Broker (RIB) architecture to allow various codecs to be enumerated and selected on the basis of any of their attributes and capabilities, including the standard file suffix of the data format they support. (See the RIB Architecture chapter for more information on the RIB interface model.) MSSCHTC.CPP and MSSCHTS.CPP demonstrate the process of selecting an ASI codec to handle a given input or output data format. The ASI codecs responsible for delivering the Voxware MetaVoice functionality are supplied in the <b>MSSVoice.ASI</b> file and include: include: </p><p>A 2900-bps high-quality fixed-rate compressor/decompressor. Suffix: ".V29" </p><p>A 2400-bps fixed-rate compressor/decompressor. Suffix: ".V24" </p><p>A 1200-bps low-bandwidth variable-rate compressor/decompressor. Suffix: ".V12" </p><p>By using each ASI codec's file suffix as a descriptor of the data format in use, MSSCHTC and MSSCHTC illustrate a way to make your chat system independent of any particular data format. When you run the Miles chat front-end (MSSCHAT.EXE), it calls MSSCHTC.EXE with the codec to use specified on the Windows command line. The client will try to find an ASI codec capable of both compression and decompression of data with the specified suffix type. Likewise, it will inform the server during the logon process that all data coming from the client will be compressed in the specified format, and that all data sent back to the client should be delivered in the same format. If both the client and the server are able to locate an ASI provider for the specified format, the link can be successfully established. </p><p>As an example of direct ASI codec access, MSSCHTC uses RIB services to locate an ASI encoder (compressor) for the data format specified on its command line. </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Find ASI provider to encode voice data for transmission<br>//<br>transmit_encoder = RIB_find_file_provider("ASI codec",<br>                                          "Output file types",<br>                                           suffix);<br>if (transmit_encoder == NULL)<br>{<br>   show_error("Error: No ASI provider available to encode data type %s\n", suffix);<br>   exit(1);<br>}<br>show_success("Using ASI provider %X to transmit data type %s\n",<br>              transmit_encoder,<br>              suffix);<br></pre></font></code><p></p><p> Once the transmit encoder provider is obtained, MSSCHTC calls RIB to obtain an interface to various functions supported by the ASI codec. (As with all RIB components, it is the requestor's responsibility to specify the interface it wants to use when communicating with a RIB service provider). </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Get ASI stream interface for transmit encoder<br>//<br>RIB_INTERFACE_ENTRY ASISTR[] =<br>{<br>   { RIB_FUNCTION, "ASI_stream_open",           (U32) &XMIT_stream_open,           RIB_NONE },<br>   { RIB_FUNCTION, "ASI_stream_close",          (U32) &XMIT_stream_close,          RIB_NONE },<br>   { RIB_FUNCTION, "ASI_stream_process",        (U32) &XMIT_stream_process,        RIB_NONE }<br>}<br>RIB_request(transmit_encoder,"ASI stream",ASISTR);<br>//<br>// Open stream with codec, registering callback function<br>//<br>transmit_stream = XMIT_stream_open(0,<br>                                   transmit_stream_callback,<br>                                   0);<br>if (transmit_stream == NULL)<br>{<br>   show_error("Could not open stream encoder\n");<br>   exit(1);<br>}<br></pre></font></code><p></p><p> Subsequently, a similar block of code is used to locate an ASI provider capable of decompressing the same data format as it is received from the server. The only difference in this case is the use of the "Input file types" attribute as the search key passed to <i>RIB_find_file_provider</i>. </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Search for ASI codec capable of processing specified input file type<br>//<br>// This ASI provider will be used to decode data sent from the server<br>// to the client<br>//<br>receive_decoder = RIB_find_file_provider("ASI codec",<br>                                         "Input file types",<br>                                          suffix);<br>if (receive_decoder == NULL)<br>{<br>   show_error("Error: No ASI provider available to decode data type %s\n",<br>              suffix);<br>   exit(1);<br>}<br></pre></font></code><p></p><p> To illustrate a "well-behaved" application's interaction with an ASI provider, the client receive provider's interface contains requests for a few key attributes and preferences, in addition to the same basic functions as those previously obtained from the transmit provider: </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Get ASI stream interface for receive decoder<br>//<br>RIB_INTERFACE_ENTRY RECVSTR[] =<br>{<br>   { RIB_FUNCTION,   "ASI_stream_attribute", (U32) &RECV.ASI_stream_attribute,    RIB_NONE },<br>   { RIB_FUNCTION,   "ASI_stream_open",      (U32) &RECV.ASI_stream_open,         RIB_NONE },<br>   { RIB_FUNCTION,   "ASI_stream_seek",      (U32) &RECV.ASI_stream_seek,         RIB_NONE },<br>   { RIB_FUNCTION,   "ASI_stream_close",     (U32) &RECV.ASI_stream_close,        RIB_NONE },<br>   { RIB_FUNCTION,   "ASI_stream_process",   (U32) &RECV.ASI_stream_process,      RIB_NONE },<br>   { RIB_FUNCTION,   "ASI_stream_set_preference", (U32) &RECV.ASI_stream_set_preference,<br>                                                                                  RIB_NONE },<br>   { RIB_ATTRIBUTE,  "Output sample rate",   (U32) &RECV.OUTPUT_SAMPLE_RATE,      RIB_NONE },<br>   { RIB_ATTRIBUTE,  "Output sample width",  (U32) &RECV.OUTPUT_BITS,             RIB_NONE },<br>   { RIB_ATTRIBUTE,  "Output channels",      (U32) &RECV.OUTPUT_CHANNELS,         RIB_NONE },<br>   { RIB_PREFERENCE, "Requested sample rate",(U32) &RECV.REQUESTED_RATE,          RIB_NONE },<br>};<br>RIB_request(receive_decoder,"ASI stream",RECVSTR);<br>//<br>// Open the receiver stream<br>//<br>// If the codec needs to inspect the stream data to<br>// configure itself, this call will block in the RECV_stream_CB()<br>// handler until the requested amount of data (typically only<br>// the first few bytes of the source stream) is received from the<br>// client.<br>//<br>RECV_read_cursor = 0;<br>RECV_write_cursor = 0;<br>RECV.stream = RECV.ASI_stream_open(0,<br>                                   RECV_stream_CB,<br>                                   0);<br>if (RECV.stream == NULL)<br>{<br>   show_error("Could not open stream decoder\n");<br>   exit(1);<br>}<br></pre></font></code><p></p><p> These attributes and preferences are used to request operation at the standard 8 kHz sample rate (HW_RATE) and to obtain the actual data format used by the codec to configure the output stream's HSAMPLE: </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// Request codec output rate which matches hardware rate<br>//<br>U32 req_rate = HW_RATE;<br>RECV.ASI_stream_set_preference(RECV.stream,<br>                               RECV.REQUESTED_RATE,<br>                              &req_rate);<br>//<br>// Stream is now open -- get its attributes and set output<br>// sample attributes accordingly<br>//<br>U32 nch  = RECV.ASI_stream_attribute(RECV.stream, RECV.OUTPUT_CHANNELS);<br>U32 rate = RECV.ASI_stream_attribute(RECV.stream, RECV.OUTPUT_SAMPLE_RATE);<br>U32 bits = RECV.ASI_stream_attribute(RECV.stream, RECV.OUTPUT_BITS);<br>S32 type;<br>if (nch == 2)<br>{<br>   type = ( (bits == 16) ? DIG_F_STEREO_16 : DIG_F_STEREO_8 ) |<br>          ( (bits == 16) ? DIG_PCM_SIGN    : 0 );<br>}<br>else<br>{<br>   type = ( (bits == 16) ? DIG_F_MONO_16   : DIG_F_MONO_8 | )<br>          ( (bits == 16) ? DIG_PCM_SIGN    : 0 );<br>}<br>AIL_init_sample             (stream);<br>AIL_set_sample_playback_rate(stream, rate);<br>AIL_set_sample_type         (stream, type, 0);<br>receive_buffer_size = AIL_minimum_sample_buffer_size(dig, rate, type);<br>show_info("Receive stream format: %d channels, %d Hz, %d bits\n",nch,rate,bits);<br>show_info("Receive buffer size=%d\n",receive_buffer_size);<br></pre></font></code><p></p><p> In reality, as noted previously, all MSS ASI providers used for voice communication are internally hardwired for operation with 16-bit monaural PCM audio at a sample rate of 8 kHz, so the above code to query the stream attributes is not, strictly speaking, necessary. However, besides being good programming (or at least typing) practice, it serves as an example of how to obtain attributes and set preferences for an ASI stream. This general technique will be useful if the application wishes to take advantage of the Voxware warping and comfort-noise masking features described below. </p><p>Once the transmit and receive providers have been selected and their corresponding streams opened successfully, all that remains to be done on the client side with respect to ASI is the actual encoding and decoding of data. The following except from <i>receive_ASI_thread_procedure</i> in MSSCHTC.CPP illustrates the use of the <i>ASI_stream_process</i> function to turn compressed audio data back into playable PCM format: </p><p></p><code><font size=3 color=#006000><pre><br>//<br>// If fetch buffer empty, call ASI decoder to acquire decompressed data<br>// from server<br>//<br>// This will block in RECV_stream_CB() until enough data is received<br>// from the server to fill the fetch buffer<br>//<br>// Using the temporary fetch buffer allows us to read and decompress<br>// data while all of the receive buffers are full -- otherwise, we'd<br>// have to spin until an empty receive buffer becomes available<br>//<br>if (!fetch_buffer_full)<br>{<br>   S32 amount = RECV.ASI_stream_process(RECV.stream,<br>                                        fetch_buffer,<br>                                        receive_buffer_size);<br>   if (amount != receive_buffer_size)<br>   {<br>      //<br>      // Bad read<br>      //<br>      active = 0;<br>      return 0;<br>   }<br>   fetch_buffer_full = 1;<br>}<br></pre></font></code><p></p><p></p>
<p><a href="Performing the Comprf339dc.html">Next Topic (Performing the Compression and Decompression)</a>  </p><p><a href="Working with Voice Input.html">Previous Topic (Working with Voice Input)</a>  </p><p>
<br>
<b>Group:</b>
<a href="Implementing Voice Chat.html">Implementing Voice Chat</a></p>
<p align=center>
<a href="mailto:Miles3@radgametools.com">For technical support, e-mail Miles3@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/miles.htm?from=help6.6h">&#169; Copyright 1991-2004 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
