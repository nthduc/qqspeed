<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>AIL_sample_buffer_ready</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="checks to see if either of two buffers associated with a sample handle are ready to be filled with new audio data by the AIL_load_sample_buffer function.">
<meta name="ms-hkwd" content="AIL_sample_buffer_ready">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Miles Sound System SDK 6.6h</a></i>
</td>
</tr>
</table>
<h1>AIL_sample_buffer_ready</h1>
<p>The function  <b>AIL_sample_buffer_ready</b> checks to see if either of two buffers associated with a sample handle are ready to be filled with new audio data by the AIL_load_sample_buffer function.</p>
<table width=100% cellspacing=0 class=pre>
<tr class=pre>
<td class=pre>
<pre><b><a href="S32.html" class=trn>S32</a> <a href="AIL_sample_buffer_ready.html" class=trn>AIL_sample_buffer_ready</a>(</b>
<b>&nbsp;&nbsp;<a href="HSAMPLE.html" class=trn>HSAMPLE</a>&nbsp;</b><i>S</i>
<b>);</b></pre>
</td>
</tr>
</table>
<h4>In Parameters</h4>
<dl>
<dt><i>S</i></dt>
<dd>indicates the sample handle to check.</dd>
</dl>
<h4>Returns</h4>
<p>0 if sample buffer 0 is ready to be filled with audio data; or, 1 if sample buffer 1 is ready to be filled with audio data; or, -1 if neither buffer needs to be serviced.</p>
<h4>Discussion</h4>
<p>There are three ways to play digital audio data with MSS. One method assumes that the entire audio sample to be played is resident in memory during playback. With this technique, the application calls <a href="AIL_set_sample_address.html">AIL_set_sample_address</a> to specify the location and size of the sample data, followed by a call to <a href="AIL_start_sample.html">AIL_start_sample</a> to begin playback of the audio data. Various functions such as <a href="AIL_set_sample_volume_pan.html">AIL_set_sample_volume_pan</a> and others allow the application to control various aspects of sample playback, before and during playback. The number of available sample handles determines how many independent samples may be played at once. </p><p> The second method is to simply use the high-level streaming services described in the "Digital Audio Streaming Services" chapter. These services allow you to stream or spool data off a hard drive or CD-ROM. </p><p> The final method, called <i>low-level double-buffering</i>, also allows full control over a sample's playback characteristics, and also permits as many samples to be played simultaneously as there are available handles. It differs from the first method in only one important way: the audio data to be passed to MSS to be played in small, manageable chunks. With double-buffering, the entire audio data sample does not need to fit into memory, so samples of any size can be played. The high-level streaming services were written using low-level double-buffering, in fact. </p><p> First, two sound data buffers are allocated by the application from system memory. The application allocates a sample handle with <a href="AIL_allocate_sample_ijfaaa.html">AIL_allocate_sample_handle</a>, initializes it with <a href="AIL_init_sample.html">AIL_init_sample</a>, sets its type and playback rate with <a href="AIL_set_sample_type.html">AIL_set_sample_type</a> and <a href="AIL_set_sample_playbug1eaa.html">AIL_set_sample_playback_rate</a>, exactly as would be done under the first method mentioned above. However, instead of using <a href="AIL_set_sample_address.html">AIL_set_sample_address</a> and <a href="AIL_start_sample.html">AIL_start_sample</a> to begin playback, an application which makes use of double-buffering would open the file containing the desired sample data, and begin repeatedly calling a small subroutine of the form: </p><p></p><code><font size=3 color=#006000><pre><br>void serve_sample(HSAMPLE sample, U8** buf, S32 size, S32 file)<br>{<br>   S32 n,len;<br>   if((n = AIL_sample_buffer_ready(sample)) != -1)<br>   {<br>      len = read(file,buf[n],size);<br>      AIL_load_sample_buffer(sample,<br>                             n,<br>                             buf[n],<br>                             len);<br>   }<br>}<br></pre></font></code><p></p><p> to begin transferring data from the file into the two buffers associated with each sample handle. </p><p> It may come as a surprise to learn that an individual sample handle can refer to <i>two</i> buffers, rather than the single conventional audio data buffer which is set up by the <a href="AIL_set_sample_address.html">AIL_set_sample_address</a> function. Normally, the second sample buffer is disabled by <a href="AIL_init_sample.html">AIL_init_sample</a>, and it cannot be accessed by the application except through the two API calls associated with double-buffering, <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a> and <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a>. Double-buffering mode is enabled automatically for a sample handle when either of these calls are used by the application, and it will remain in effect until the next <a href="AIL_init_sample.html">AIL_init_sample</a> call for that sample handle. In double-buffering mode, MSS begins playing the contents of the first buffer (we'll call this one <i>buffer 0</i>) as soon as the first chunk of sample data is loaded into it and <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a> is called for the first time. The next call to <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a> will return a value of 1, to indicate that the second buffer (called <i>buffer 1</i>) should be filled next. Once both buffers have been filled with sample data, subsequent calls to <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a> will return a value of -1, meaning that neither buffer needs to be filled with audio data (or serviced) for the moment. </p><p> As soon as buffer 0 finishes playing MSS will immediately switch back to buffer 0 (whose contents have been updated since the last time it was played) and keep playing. </p><p> Double-buffered playback stops when a function such as <a href="AIL_stop_sample.html">AIL_stop_sample</a> or <a href="AIL_end_sample.html">AIL_end_sample</a> is used, or when a buffer of length 0 is reached (this occurs at end-of-file when <i>read</i> is used in the example above). From the foregoing discussion, it should be apparent that the application must check the buffers' status with <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a> frequently enough to avoid buffer "starvation" a condition in which playback stops because new data has not been provided in a timely fashion. In general, the application should call its <i>serve_sample</i> routine, or perform a similar action, at a rate of better than half of either buffer's playback period. The playback period in seconds for a given buffer is equal to the buffer's size in bytes divided by the playback rate in samples per second. This period must be further divided by the number of bytes per sample (4 for stereo 16-bit samples, 1 for mono 8-bit samples, and so forth). </p><p> At first glance, the example <i>serve_buffer</i> subroutine above would seem an ideal candidate for an MSS background timer service client. Under Win32 and MacOS X, this would work fine, but you will stall timer services for the duration of the IO routine. Worse, under DOS, the C <i>read</i> function must call DOS (and the DOS extender) to read audio data from the sample file. While it is theoretically possible to perform DOS file access from a timer-based interrupt handler, doing so requires techniques which are beyond the scope of this documentation or any MSS example program. These techniques may or may not be usable with certain DOS extenders, so any attempt at DOS access from a timer callback function is made entirely at the programmer's risk. Although it is customary that both buffers be the same size, it is not mandatory. The two buffers may be of different sizes if necessary, and their sizes may be changed "on the fly." (This normally happens when the very last chunk of audio data is read from the sample file unless the sample file's size happens to be an integer multiple of the buffer size.) It is important that the size of each individual buffer be equal to or larger than the value returned by the <a href="AIL_minimum_sample_bahfkoa.html">AIL_minimum_sample_buffer_size</a> function, since the application's buffers cannot be smaller than the hardware-level buffers (see below). </p><p> Double-buffered audio data is normally stored in raw form. It cannot be stored in the form of .VOC or .WAV files, unless the application itself assumes responsibility for seeking past the header and terminator blocks in these files. .VOC or .WAV files may be converted to raw data with the Miles Sound Studio utility; or with the RAD Video Tools which are available at our <a href="http://www.radgametools.com">web-site</a>. The <a href="AIL_set_sample_file.html">AIL_set_sample_file</a> function may be helpful in parsing .VOC and .WAV files as well. </p><p> It is possible to mix double-buffered samples and conventional memory-resident samples freely. However, it may not be advisable to play more than one double-buffered sample at once, because the system overhead required to continually stream data from two separate DOS files may give rise to sound dropouts, depending on the data rates involved. Experimentation and careful testing are recommended in such cases. </p><p> To loop a double-buffered sample, it is necessary to trap the end-of-file condition (zero bytes read) and seek back to the file's beginning to re-execute the <i>read</i> call. The <a href="AIL_set_sample_loop_count.html">AIL_set_sample_loop_count</a> function is not applicable to double-buffered samples, since it can be used only when the entire sample is resident in memory. If used, it will cause only the currently playing buffer to loop, which is not likely to be the desired result. </p><p> If this function returns a 0 or 1 (meaning a buffer is ready), you must always call <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a> before you call <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a> again, or the internal state machine that MSS uses for double buffering can get out of sync. This means that you should structure your double buffering logic such that you always have sound data ready for <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a> before you query <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a>. </p><p> MSS's built-in double-buffering mechanism (namely, the <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a> and <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a> functions) cannot be used to play buffers which are smaller than the hardware half-buffer size used at the hardware level, because the hardware buffer can be filled with sample </p><p> On MacOS, you should use the system file reading function, <i>PBRead</i> which provides asynchronous data reading. </p><p> Example files that use this function: DBTEST.C</p>
<p>
<br>
<b>Group:</b>
<a href="2D Digital Audio Services.html">2D Digital Audio Services</a><br>
<b>Related Functions:</b>
<a href="AIL_allocate_sample_ijfaaa.html">AIL_allocate_sample_handle</a>, <a href="AIL_end_sample.html">AIL_end_sample</a>, <a href="AIL_init_sample.html">AIL_init_sample</a>, <a href="AIL_load_sample_buffer.html">AIL_load_sample_buffer</a>, <a href="AIL_minimum_sample_bahfkoa.html">AIL_minimum_sample_buffer_size</a>, <a href="AIL_sample_buffer_info.html">AIL_sample_buffer_info</a>, <a href="AIL_sample_buffer_ready.html">AIL_sample_buffer_ready</a>, <a href="AIL_set_sample_address.html">AIL_set_sample_address</a>, <a href="AIL_set_sample_file.html">AIL_set_sample_file</a>, <a href="AIL_set_sample_loop_count.html">AIL_set_sample_loop_count</a>, <a href="AIL_set_sample_playbug1eaa.html">AIL_set_sample_playback_rate</a>, <a href="AIL_set_sample_type.html">AIL_set_sample_type</a>, <a href="AIL_set_sample_volume_pan.html">AIL_set_sample_volume_pan</a>, <a href="AIL_start_sample.html">AIL_start_sample</a>, <a href="AIL_stop_sample.html">AIL_stop_sample</a><br>
<b>Related Basic Types:</b>
<a href="HSAMPLE.html">HSAMPLE</a>, <a href="S32.html">S32</a></p>
<p align=center>
<a href="mailto:Miles3@radgametools.com">For technical support, e-mail Miles3@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/miles.htm?from=help6.6h">&#169; Copyright 1991-2004 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
