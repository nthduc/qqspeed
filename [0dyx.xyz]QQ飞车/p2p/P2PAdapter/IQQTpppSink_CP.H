
// Wizard-generated connection point proxy class
// WARNING: This file may be regenerated by the wizard


#pragma once

template<class T>
class CProxyIQQTpppSink :
	public IConnectionPointImpl<T, &__uuidof(IQQTpppSink)>
{
public:
	HRESULT Fire_OnUdpLoginOk()
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->OnUdpLoginOk();
			}
		}
		return hr;
	}
	HRESULT Fire_OnRecvP2PDataFromSvr( short  shPlayerID,  int  nBodyLen,  BYTE *  pBody)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->OnRecvP2PDataFromSvr(shPlayerID, nBodyLen, pBody);
			}
		}
		return hr;
	}
	HRESULT Fire_OnGetPlayerInfoFromSvr( short  shPlayerID,  int  nUin)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->OnGetPlayerInfoFromSvr(shPlayerID, nUin);
			}
		}
		return hr;
	}
	HRESULT Fire_OnRecvClientTry2ConnectData( short  shPlayerID,  int  nUin,  ULONG  ulTestMyIP,  USHORT  usTestMyPort)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->OnRecvClientTry2ConnectData(shPlayerID, nUin, ulTestMyIP, usTestMyPort);
			}
		}
		return hr;
	}
	HRESULT Fire_OnRecvP2PGameDataFromClient( short  shSocketPlayerID,  int  nSocketPlayerUin,  short  shPlayerID,  int  nBodyLen,  BYTE *  pBody)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->OnRecvP2PGameDataFromClient(shSocketPlayerID, nSocketPlayerUin, shPlayerID, nBodyLen, pBody);
			}
		}
		return hr;
	}
	HRESULT Fire_SendTcpP2pData( int  nPlayerCount,  short *  asPlayerID,  int *  aiUin,  int  iLen,  BYTE *  pData)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IQQTpppSink * pConnection = static_cast<IQQTpppSink *>(punkConnection.p);

			if (pConnection)
			{
				hr = pConnection->SendTcpP2pData(nPlayerCount, asPlayerID, aiUin, iLen, pData);
			}
		}
		return hr;
	}
};

